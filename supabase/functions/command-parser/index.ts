import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient, SupabaseClient } from "https://esm.sh/@supabase/supabase-js@2.45.0";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

// --- Helper Functions ---

function normalizeOperator(op: string): string {
  const map: { [key: string]: string } = {
    "is greater than": ">",
    "is above": ">",
    "greater than": ">",
    ">": ">",
    "is less than": "<",
    "is below": "<",
    "less than": "<",
    "<": "<",
    "crosses above": "crosses_above",
    "crosses below": "crosses_below",
  };
  return map[op.toLowerCase().trim()] || ">";
}

function parseStrategyCommand(command: string) {
  const strategy: any = {
    name: null,
    description: "Generated by AI Assistant",
    symbols: null,
    timeframe: null,
    conditions: [],
  };

  // Extract name
  const nameMatch = command.match(/(?:called|named|name it) ['"]?([^'"]+)['"]?/i);
  strategy.name = nameMatch ? nameMatch[1] : `My AI Strategy ${new Date().toLocaleTimeString()}`;

  // Extract symbols
  const symbolMatch = command.match(/for (?:symbol[s]?)?([A-Z0-9,\s/]+)/i);
  if (symbolMatch) {
    strategy.symbols = symbolMatch[1].split(',').map(s => s.trim()).filter(Boolean);
  }

  // Extract timeframe
  const timeframeMatch = command.match(/on (?:a |the )?(\d+(?:m|h|d))/i);
  strategy.timeframe = timeframeMatch ? timeframeMatch[1] : '15m';

  // Extract conditions
  const conditionRegex = /when (?:the )?(Price|RSI|SMA50|SMA200)\s+(is greater than|is above|greater than|>|is less than|is below|less than|<|crosses above|crosses below)\s+(?:the )?(\d+|Price|RSI|SMA50|SMA200)/gi;
  let match;
  while ((match = conditionRegex.exec(command)) !== null) {
    strategy.conditions.push({
      indicator: match[1],
      operator: normalizeOperator(match[2]),
      value: match[3],
    });
  }

  // Validation
  if (!strategy.symbols || strategy.symbols.length === 0 || strategy.conditions.length === 0) {
    return { error: "I couldn't understand the command. Please use the example format, making sure to include at least one symbol (e.g., 'for TSLA') and one condition (e.g., 'when RSI is below 30')." };
  }

  return { strategy };
}


async function create_strategy(supabase: SupabaseClient, userId: string, args: any) {
  const { error } = await supabase.from('strategies').insert({ ...args, user_id: userId, status: 'stopped' });
  if (error) throw new Error(error.message);
  return `Successfully created the "${args.name}" strategy. You can view and activate it on the Strategies page.`;
}


// --- Main Server Logic ---

serve(async (req) => {
  if (req.method === "OPTIONS") return new Response("ok", { headers: corsHeaders });

  try {
    const { messages } = await req.json();
    if (!messages || messages.length === 0) {
      throw new Error("Missing 'messages' in request body.");
    }
    
    const userMessage = messages[messages.length - 1].content;

    const authHeader = req.headers.get("Authorization");
    if (!authHeader) throw new Error("Missing authorization header.");

    const supabase = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SUPABASE_ANON_KEY")!,
      { global: { headers: { Authorization: authHeader } } }
    );
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) throw new Error("Authentication failed.");

    const parseResult = parseStrategyCommand(userMessage);

    if (parseResult.error) {
      return new Response(JSON.stringify({ reply: parseResult.error, success: false }), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    const result = await create_strategy(supabase, user.id, parseResult.strategy);

    return new Response(JSON.stringify({ reply: result, success: true }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });

  } catch (error) {
    console.error("Error in command parser:", error);
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 500,
    });
  }
});